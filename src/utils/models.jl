using FastPow
using LinearAlgebra
using Polyester
using StaticArrays


"""
    sphere!(x, f, m, c, r, χ, bdir, vsz)

Add a sphere to grid.

### Arguments
- `x::AbstractArray{T1, 3}`: magnetic susceptibilities
- `f::AbstractArray{T2, 3}`: local field generated by magnetic susceptibilities
- `m::AbstractArray{Bool, 3}`: binary mask of magnetic susceptibilities
- `c::Union{NTuple{3}, SVector{3}}`: center of source to add; c[i] ∈ (1:size(x,i))
- `r::Real`: radius of source to add
- `χ::Real`: magnetic susceptibility of new source in ppm
- `bdir::NTuple{3, Real}`: unit vector of B-field direction (x, y, z)
- `vsz::NTuple{3, Real}`: voxel size

### Returns
- `x`
- `f`
- `m`

### References
    [1] Cheng, Y. C. N., Neelavalli, J., & Haacke, E. M. (2009). Limitations of
    calculating field distributions and magnetic susceptibilities in MRI using
    a Fourier based method. Physics in Medicine & Biology, 54(5), 1169.
"""
function sphere!(
    x::AbstractArray{T1, 3},
    f::AbstractArray{T2, 3},
    m::AbstractArray{Bool, 3},
    c::Union{NTuple{3}, SVector{3}},
    r::Real,
    χ::Real,
    bdir::NTuple{3, Real},
    vsz::NTuple{3, Real},
) where {T1, T2}
    size(x) == size(f) || throw(DimensionMismatch())
    size(f) == size(m) || throw(DimensionMismatch())
    checkbounds(Bool, x, CartesianIndex(c...)) || throw(DimensionMismatch())

    sz = size(x)
    nx, ny, nz = sz

    C = SVector{3, Float64}(c)
    B = SVector{3, Float64}(bdir)
    ns = SVector{3, Float64}(sz)
    dx = SVector{3, Float64}(vsz)

    if !(norm(B) ≈ 1)
        @warn "B direction vector is not normalized. Normalizing..."
        B = B ./ norm(B)
    end

    X, Y, Z = _grid(C, ns, dx, sz)
    C = C .+ first.((X, Y, Z))

    chi = Float64(χ)
    r2 = Float64(r^2)
    a = Float64(1//3*χ*r^3)

    @batch for k in 1:nz
        @inbounds for j in 1:ny
            @fastpow for i in 1:nx
                R = SVector{3, Float64}(X[i], Y[j], Z[k]) - C
                R2 = R⋅R

                if R2 <= r2 # inside sphere, field = 0
                    x[i,j,k] += chi
                    m[i,j,k] = true
                else        # outside sphere, compute field
                    Rz = R⋅B
                    _f = (3*Rz^2-R2)/sqrt(R2^5)
                    f[i,j,k] = muladd(a, _f, f[i,j,k])
                end
            end
        end
    end

    return x, f, m
end


"""
    cylinder!(x, f, m, c, r, θ, ϕ, χ, bdir, vsz)

Add an infinite cylinder to grid.

### Arguments
- `x::AbstractArray{T1, 3}`: magnetic susceptibilities
- `f::AbstractArray{T2, 3}`: local field generated by magnetic susceptibilities
- `m::AbstractArray{Bool, 3}`: binary mask of magnetic susceptibilities
- `c::Union{NTuple{3}, SVector{3}}`: center of source to add; c[i] ∈ (1:size(x,i))
- `r::Real`: radius of source to add
- `θ::Real`: polar angle wrt B-field of cylinder
- `ϕ::Real`: azimuthal angle wrt B-field of cylinder
- `χ::Real`: magnetic susceptibility of new source in ppm
- `bdir::NTuple{3, Real}`: unit vector of B-field direction (x, y, z)
- `vsz::NTuple{3, Real}`: voxel size

### Returns
- `x`
- `f`
- `m`

### References
    [1] Cheng, Y. C. N., Neelavalli, J., & Haacke, E. M. (2009). Limitations of
    calculating field distributions and magnetic susceptibilities in MRI using
    a Fourier based method. Physics in Medicine & Biology, 54(5), 1169.
"""
function cylinder!(
    x::AbstractArray{T1, 3},
    f::AbstractArray{T2, 3},
    m::AbstractArray{Bool, 3},
    c::Union{NTuple{3}, SVector{3}},
    r::Real,
    θ::Real,
    ϕ::Real,
    χ::Real,
    bdir::NTuple{3, Real},
    vsz::NTuple{3, Real},
) where {T1, T2}
    size(x) == size(f) || throw(DimensionMismatch())
    size(f) == size(m) || throw(DimensionMismatch())
    checkbounds(Bool, x, CartesianIndex(c...)) || throw(DimensionMismatch())

    sz = size(x)
    nx, ny, nz = sz

    C = SVector{3, Float64}(c)
    ns = SVector{3, Float64}(sz)
    dx = SVector{3, Float64}(vsz)

    if !(norm(bdir) ≈ 1)
        @warn "B direction vector is not normalized. Normalizing..."
        bdir = bdir ./ norm(bdir)
    end

    X, Y, Z = _grid(C, ns, dx, sz)

    bz = Float64(bdir[3])
    theta = Float64(θ)
    phi = Float64(ϕ)
    chi = Float64(χ)
    ρ = Float64(r)

    B = cos(acos(bz) - theta)
    F = 1/6 * chi * (3*B^2 - 1) # constant field inside cylinder
    a = 0.5*chi * ρ^2 * sin(acos(B))^2

    e = SVector{3, Float64}(sin(theta)*cos(phi), sin(theta)*sin(phi), cos(theta))

    @batch for k in 1:nz
        @inbounds for j in 1:ny
            @fastpow for i in 1:nx
                R = SVector{3, Float64}(X[i], Y[j], Z[k])

                # mathworld.wolfram.com/Point-LineDistance3-Dimensional.html
                if norm(R×(R-e)) <= ρ # inside cylinder, constant field
                    f[I] += F
                    x[I] += chi
                    m[I] = true
                else                     # outside cylinder, compute field
                    if iszero(theta)
                        j = SVector{3, Float64}(0, 1, 0)
                        i = SVector{3, Float64}(1, 0, 0)
                    else
                        # j = k×z, z = (0, 0, 1), k = e
                        j = SVector{3, Float64}(e[2], -e[1], 0)
                        j = j .* inv(norm(j))
                        i = j×e
                    end
                    Rx2 = (R⋅i)^2
                    Ry2 = (R⋅j)^2
                    _f = (Rx2 - Ry2)/(Rx2 + Ry2)^2

                    f[i,j,k] = muladd(a, _f, f[i,j,k])
                end
            end
        end
    end

    return x, f, m
end


function _grid(
    c::Union{NTuple{N}, SVector{N}},
    sz::Union{NTuple{N}, SVector{N}},
    dx::Union{NTuple{N}, SVector{N}},
    ns::Union{NTuple{N}, SVector{N}}
) where {N}
    x = dx .* fld.(sz, 2)
    return ntuple(i -> range(-x[i], step=dx[i], length=ns[i]), Val(N))
end
